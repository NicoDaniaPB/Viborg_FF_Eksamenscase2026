# 6. Fit REDUCERET model --------------------------------------------------
reduceret_model <- lm(
tilskuere ~ d10_tilskuere + d7_tilskuere + runde +
stadion_kapacitet + mål_hjemme + mål_ude,
data = train_data
)
summary(reduceret_model)
# -------- NYT: Tjek multikollinearitet i reduceret model -----------------
vif(reduceret_model)
# 7. Predict og evaluer reduceret model ----------------------------------
pred_test_reduceret <- predict(reduceret_model, newdata = test_data)
rmse_reduceret <- sqrt(mean((test_data$tilskuere - pred_test_reduceret)^2))
rmse_reduceret
pacman::p_load("tidyverse", "forcats", "ggplot2", "glmnet", "leaps", "caret", "purrr", "car", "tibble")
# 1. Load data -------------------------------------------------------------
VFF_samlet_variabler <- readRDS("VFFdata/VFF_samlet_variabler.rds")
# Vi konverter relevante variabler til faktorer
# Vi bruger mutate til at bygge videre på de samlet variabler, og definer dem
# "as factor".Dette er vigtigt i forbindelse med lineær regression, hvor
# faktorvariable behandles som kategoriske og derfor omsættes til dummyvariable
# i matricen.
VFF_samlet_variabler <- VFF_samlet_variabler |>
mutate(
udehold_rang    = as.factor(udehold_rang),
Er_helligdag    = as.factor(Er_helligdag),
i_sommerferie   = as.factor(i_sommerferie),
i_efterårsferie = as.factor(i_efterårsferie),
i_vinterferie   = as.factor(i_vinterferie),
ferieperiode    = as.factor(ferieperiode),
udehold         = as.factor(udehold)
)
# Vi konverter relevante variabler til faktorer
# Vi bruger mutate til at bygge videre på de samlet variabler, og definer dem
# "as factor".Dette er vigtigt i forbindelse med lineær regression, hvor
# faktorvariable behandles som kategoriske og derfor omsættes til dummyvariable
# i matricen.
VFF_samlet_variabler <- VFF_samlet_variabler |>
mutate(
udehold_rang    = as.factor(udehold_rang),
Er_helligdag    = as.factor(Er_helligdag),
i_sommerferie   = as.factor(i_sommerferie),
i_efterårsferie = as.factor(i_efterårsferie),
i_vinterferie   = as.factor(i_vinterferie),
ferieperiode    = as.factor(ferieperiode),
udehold         = as.factor(udehold)
)
VFF_samlet_variabler <- VFF_samlet_variabler |>
add_count(udehold, name = "n_udehold") |>
mutate(
små_hold = if_else(n_udehold > 2, "stor hold", as.character(udehold)),
små_hold = as.factor(små_hold)
) |>
select(-n_udehold)
view(VFF_samlet_variabler)
set.seed(1)
n <- nrow(VFF_samlet_variabler)
train_index <- sample(1:n, size = round(0.7*n))
train_data <- VFF_samlet_variabler[train_index, ]
test_data  <- VFF_samlet_variabler[-train_index, ]
glimpse(train_data)
glimpse(test_data)
# Vi sikrer at test_data kun har niveauer, som modellen kender
# Vi bruger mutate til at bygge videre på test_dataene, og sørger for, udehold
# gendannes som faktor med samme levels som i træningsdataene.
# Levels(train_data$udehold henter alle de niveauer, som udehold har i trænings-
#-datasættet
test_data <- test_data %>%
mutate(
udehold = factor(udehold, levels = levels(train_data$udehold))
)
# Lineær model med billetsalg 3 dage før kampstart
stor_lm_model <- lm(
tilskuere ~ temp_dry + wind_speed + nedbør_seneste_7_timer +
ugedag + placering_lag_hjemme + placering_lag_ude + mål_seneste_3_hjemme
+ mål_sæson_lag_hjemmehold + mål_sæson_lag_udehold + form_seneste_3_hjemmehold
+ form_seneste_3_udehold + tilskuere_hold_lag + udehold_rang + sæson + runde + tidsperiode +
Er_helligdag + i_sommerferie + i_efterårsferie + i_vinterferie +
ferieperiode + total_income + total_expense + net_balance +
antal_transfers + d3_tilskuere + stadion_kapacitet,
data = train_data
)
summary(stor_lm_model)
# Test for multikollinearitet - VIF (Variance inflation factor) via car-pakken
vif(stor_lm_model)
# Vi finder de perfekte lineære afhængigheder
alias(stor_lm_model)
# Designmatrix-rank (bekræftelse af multikollinearitet problemet
kampdag_X <- model.matrix(stor_lm_model)
qr(kampdag_X)$rank
ncol(kampdag_X)
# Ny model - 3 dage før
stor_lm_model_ny <- lm(
tilskuere ~
temp_dry + wind_speed + nedbør_seneste_7_timer +
tidsperiode +
placering_lag_hjemme + placering_lag_ude +
mål_seneste_3_hjemme +
mål_sæson_lag_udehold +
form_seneste_3_hjemmehold + form_seneste_3_udehold + d3_tilskuere +
udehold_rang +
sæson + runde +
ferieperiode +
net_balance +
stadion_kapacitet,
data = train_data
)
summary(stor_lm_model_ny)
# Vi tester igen for multikollinearitet - VIF (Variance inflation factor) via car-pakken
# Model.matrix udtrækker desginmatricen fra modellen
# qr() laver en QR-dekomposition af designmatricen
# $rank er antalelt af lineært uafhængige kolonner i X (som vi har defineret som
# modelmatricen)
# ncol tæller antallet af regressorer i modellen, dvs det antal af kolonner, som
# ikke er lineært afhængige af hinanden.
# alias() identificer hvilke variabler der er 100% lineære afhængige af hinanden.
X <- model.matrix(stor_lm_model_ny)
qr(X)$rank
ncol(X)
alias(stor_lm_model_ny)
# Det kan ses, at net_balance skyldes fejlen. Den fjerner vi nu
stor_lm_model_ny <- lm(
tilskuere ~
temp_dry + wind_speed + nedbør_seneste_7_timer +
tidsperiode +
placering_lag_hjemme + placering_lag_ude +
mål_seneste_3_hjemme +
mål_sæson_lag_udehold +
form_seneste_3_hjemmehold + form_seneste_3_udehold +
d3_tilskuere +
udehold_rang +
sæson + runde +
ferieperiode +
stadion_kapacitet,
data = train_data
)
summary(stor_lm_model_ny)
# Vi tester igen for multikollinearitet - VIF (Variance inflation factor) via car-pakken
# Model.matrix udtrækker desginmatricen fra modellen
# qr() laver en QR-dekomposition af designmatricen
# $rank er antallet af lineært uafhængige kolonner i X (som vi har defineret som
# modelmatricen)
# ncol tæller antallet af regressorer i modellen, dvs det antal af kolonner, som
# ikke er lineært afhængige af hinanden.
# alias() identificer hvilke variabler der er 100% lineære afhængige af hinanden.
X <- model.matrix(stor_lm_model_ny)
X <- model.matrix(stor_lm_model_ny)
qr(X)$rank
ncol(X)
alias(stor_lm_model_ny)
# Nu er der 42/42, så ingen lineære afhængighed.
# Vi tester nu for VIF igen.
vif(stor_lm_model_ny)
stor_lm_model_3_dage <- lm(
tilskuere ~
temp_dry + wind_speed + nedbør_seneste_7_timer +
tidsperiode +
placering_lag_hjemme + placering_lag_ude +
mål_seneste_3_hjemme +
form_seneste_3_hjemmehold + form_seneste_3_udehold +
d3_tilskuere +
udehold_rang +
sæson + runde +
ferieperiode +
stadion_kapacitet,
data = train_data
)
summary(stor_lm_model_3_dage)
# Vi tester nu for VIF igen.
vif(stor_lm_model_3_dage)
# Model 7 dage før
stor_lm_model_7_dage <- lm(
tilskuere ~
temp_dry + wind_speed + nedbør_seneste_7_timer +
tidsperiode +
placering_lag_hjemme + placering_lag_ude +
mål_seneste_3_hjemme +
form_seneste_3_hjemmehold + form_seneste_3_udehold +
d7_tilskuere +
udehold_rang +
sæson + runde +
ferieperiode +
stadion_kapacitet,
data = train_data
)
summary(stor_lm_model_7_dage)
# Model 10 dage før
stor_lm_model_10_dage <- lm(
tilskuere ~
temp_dry + wind_speed + nedbør_seneste_7_timer +
tidsperiode +
placering_lag_hjemme + placering_lag_ude +
mål_seneste_3_hjemme +
form_seneste_3_hjemmehold + form_seneste_3_udehold +
d10_tilskuere +
udehold_rang +
sæson + runde +
ferieperiode +
stadion_kapacitet,
data = train_data
)
summary(stor_lm_model_10_dage)
# Model flere måneder før
stor_lm_model_flere_måneder <- lm(
tilskuere ~ sæson + runde + tidsperiode
+ ferieperiode + stadion_kapacitet,
data = train_data
)
summary(stor_lm_model_flere_måneder)
vif(stor_lm_model_flere_måneder)
# 4. Predict på testdata ---------------------------------------------------
# Vi bruger predict til at tage koefficientere fra den estimerede model, (som
# vi har defineret foroven).
tilskuere_hat3 <- predict(stor_lm_model_3_dage, newdata = test_data)
tilskuere_hat7 <- predict(stor_lm_model_7_dage, newdata = test_data)
tilskuere_hat10 <- predict(stor_lm_model_10_dage, newdata = test_data)
tilskuere_hat_flere_måneder <- predict(stor_lm_model_flere_måneder, newdata = test_data)
calc_metrics <- function(obs, pred) {
mse <- mean((obs - pred)^2)
rmse <- sqrt(mse)
ss_res <- sum((obs - pred)^2)
ss_tot <- sum((obs - mean(obs))^2)
r2 <- 1 - ss_res/ss_tot
return(list(MSE = mse, RMSE = rmse, R2 = r2))
}
# Vi definer vores modeller, og hvad der skal beregnes
metrics_3_dage    <- calc_metrics(test_data$tilskuere, tilskuere_hat3)
metrics_7_dage    <- calc_metrics(test_data$tilskuere, tilskuere_hat7)
metrics_10_dage   <- calc_metrics(test_data$tilskuere, tilskuere_hat10)
metrics_flere_måneder   <- calc_metrics(test_data$tilskuere, tilskuere_hat_flere_måneder)
# Vi ser resultateterne for vores lineære regressionsmodeller
metrics_3_dage
metrics_7_dage
metrics_10_dage
metrics_flere_måneder
# Vi samler resultaterne i en tibble
# Vi smider de i en tibble, og bruger c (combine) til kombiner de forskellige
# modeller for de forskellige perioder, og nøgletallene for hver model.
metrics_samlet <- tibble(
Model = c("3 dage før", "7 dage før", "10 dage før", "flere måneder"),
MSE  = c(metrics_3_dage$MSE, metrics_7_dage$MSE, metrics_10_dage$MSE, metrics_flere_måneder$MSE),
RMSE = c(metrics_3_dage$RMSE, metrics_7_dage$RMSE, metrics_10_dage$RMSE, metrics_flere_måneder$RMSE),
R2   = c(metrics_3_dage$R2, metrics_7_dage$R2, metrics_10_dage$R2, metrics_flere_måneder$R2)
)
glimpse(metrics_samlet)
# Vi starter med at samle dataene til plottet.
# vi bruger bind rows til at sættrer rækkerne fra de forskellige tabeller sammen.
# Vi har vores model, vores observeret værdi og vores forudsagte (predicted)
# værdi.
plot_data <- bind_rows(
tibble(
Model = "3 dage før",
Observed = test_data$tilskuere,
Predicted = tilskuere_hat3
),
tibble(
Model = "7 dage før",
Observed = test_data$tilskuere,
Predicted = tilskuere_hat7
),
tibble(
Model = "10 dage før",
Observed = test_data$tilskuere,
Predicted = tilskuere_hat10
),
tibble(
Model = "Flere måneder før",
Observed = test_data$tilskuere,
Predicted = tilskuere_hat_flere_måneder
)
)
ggplot(plot_data, aes(x = Observed, y = Predicted)) +
geom_point(alpha = 0.4) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
facet_wrap(~ Model, scales = "free") +
labs(
title = "Observeret vs. forudsagt tilskuertal",
x = "Observeret",
y = "Forudsagt"
) +
theme_minimal()
# Lambda-grid
# Vi opretter 100 lamda-værdier fra 10^5 til 10^-3
# Vi bruger det til regularisering i shrinkage metoder (Ridge og Lasso).
# Jo større lamda-værdien er, jo større er straffen. En lille lambda-værdi, er
# næsten det samme som almindelig lineær regression. Vi vurder 100 lambda-værdier,
# til at være tilstrækkeligt.
lambda_grid <- 10^seq(5, -3, length = 100)
# Funktion til metrics
# Vi opretter en funktion, som vi kalder "calc_metrics".
# obs er de observerede værdier (dvs faktiske tilskuertal)
# pred er forudsagtes værdier fra vores model
# Efter det skriver vi formlerne til at beregne hhv. MSE, RMSE og R^2.
# Til sidst returnerer vi en liste med alle tre metrics.
calc_metrics <- function(obs, pred) {
mse <- mean((obs - pred)^2)
rmse <- sqrt(mse)
ss_res <- sum((obs - pred)^2)
ss_tot <- sum((obs - mean(obs))^2)
r2 <- 1 - ss_res / ss_tot
list(MSE = mse, RMSE = rmse, R2 = r2)
}
# Funktion til at lave metrics tibble
# Vi pakker vores resultater i en tibble med vores værdier, og hvilke modeltype
# det er. Formålet her, at at gære resultaterne lettere at sammenligne og samle.
make_metrics_tibble <- function(obs, pred, model_name, lambda, periode) {
metrics <- calc_metrics(obs, pred)
tibble(
Model = model_name,
Lambda = lambda,
MSE = metrics$MSE,
RMSE = metrics$RMSE,
R2 = metrics$R2,
Periode = periode
)
}
# Base features
# Vi definer de fælles forklarende variabler for de fleste modeller.
# Vi bruger combine (c) til at sammensætte de forskellige variabler.
base_features <- c(
"temp_dry", "wind_speed", "nedbør_seneste_7_timer",
"ugedag",
"placering_lag_hjemme", "placering_lag_ude",
"form_seneste_3_hjemmehold", "form_seneste_3_udehold",
"udehold_rang",
"sæson", "runde", "tidsperiode",
"ferieperiode",
"antal_transfers",
"stadion_kapacitet"
)
# Features for hvert tidspunkt
# Vi laver fire modeller med forskellige tidshorisonter.
# Vi bruger combine (c) til at kombinerer base_features, som vi defineret
# foroven, samt billetsalg varaibel og mål i seneste 3 hjemmekampe.
# I "flere måneder"-modellen definerer hvilke variabler der skal med via
# combine (c).
features_list <- list(
"3 dage" = c(base_features, "d3_tilskuere", "mål_seneste_3_hjemme"),
"7 dage" = c(base_features, "d7_tilskuere", "mål_seneste_3_hjemme"),
"10 dage" = c(base_features, "d10_tilskuere", "mål_seneste_3_hjemme"),
"flere måneder" = c(
"ugedag", "sæson", "runde", "tidsperiode",
"ferieperiode", "antal_transfers", "stadion_kapacitet"
)
)
run_ridge_best_lambda <- function(features, periode) {
formula <- as.formula(paste("tilskuere ~", paste(features, collapse = "+")))
x_train <- model.matrix(formula, train_data)[, -1]
y_train <- train_data$tilskuere
x_test_raw <- model.matrix(formula, test_data)[, -1]
x_test <- matrix(0, nrow = nrow(x_test_raw), ncol = ncol(x_train))
colnames(x_test) <- colnames(x_train)
common_cols <- intersect(colnames(x_test_raw), colnames(x_train))
x_test[, common_cols] <- x_test_raw[, common_cols]
ridge_mod <- glmnet(x_train, y_train, alpha = 0, lambda = lambda_grid)
metrics <- bind_rows(lapply(seq_along(ridge_mod$lambda), function(i) {
pred <- predict(ridge_mod, s = ridge_mod$lambda[i], newx = x_test)
make_metrics_tibble(
obs = test_data$tilskuere,
pred = pred,
model = "Ridge",
lambda = ridge_mod$lambda[i],
periode = periode
)
}))
metrics[which.min(metrics$MSE), ]
}
run_lasso_best_lambda <- function(features, periode) {
formula <- as.formula(paste("tilskuere ~", paste(features, collapse = "+")))
x_train <- model.matrix(formula, train_data)[, -1]
y_train <- train_data$tilskuere
x_test_raw <- model.matrix(formula, test_data)[, -1]
x_test <- matrix(0, nrow = nrow(x_test_raw), ncol = ncol(x_train))
colnames(x_test) <- colnames(x_train)
common_cols <- intersect(colnames(x_test_raw), colnames(x_train))
x_test[, common_cols] <- x_test_raw[, common_cols]
lasso_mod <- glmnet(x_train, y_train, alpha = 1, lambda = lambda_grid)
metrics <- bind_rows(lapply(seq_along(lasso_mod$lambda), function(i) {
pred <- predict(lasso_mod, s = lasso_mod$lambda[i], newx = x_test)
make_metrics_tibble(
obs = test_data$tilskuere,
pred = pred,
model = "Lasso",
lambda = lasso_mod$lambda[i],
periode = periode
)
}))
metrics[which.min(metrics$MSE), ]
}
# Vi laver et loop over alle perioder i features_listen, og kører
# run_ridge_best_lambda. Og vi bruger bind_rows funktioenn til at binde resultaterne
# i en tibble med den bedste lambda og de bedste metrics for hver periode.
metrics_ridge_best <- bind_rows(
lapply(names(features_list), function(p) {
run_ridge_best_lambda(features_list[[p]], p)
})
)
# Vi laver et loop over alle perioder i features_listen, og kører
# run_ridge_best_lambda. Og vi bruger bind_rows funktioenn til at binde resultaterne
# i en tibble med den bedste lambda og de bedste metrics for hver periode.
metrics_ridge_best <- bind_rows(
lapply(names(features_list), function(p) {
run_ridge_best_lambda(features_list[[p]], p)
})
)
metrics[which.min(metrics$MSE), ]
run_lasso_best_lambda <- function(features, periode) {
formula <- as.formula(paste("tilskuere ~", paste(features, collapse = "+")))
x_train <- model.matrix(formula, train_data)[, -1]
y_train <- train_data$tilskuere
x_test_raw <- model.matrix(formula, test_data)[, -1]
x_test <- matrix(0, nrow = nrow(x_test_raw), ncol = ncol(x_train))
colnames(x_test) <- colnames(x_train)
common_cols <- intersect(colnames(x_test_raw), colnames(x_train))
x_test[, common_cols] <- x_test_raw[, common_cols]
lasso_mod <- glmnet(x_train, y_train, alpha = 1, lambda = lambda_grid)
metrics <- bind_rows(lapply(seq_along(lasso_mod$lambda), function(i) {
pred <- predict(lasso_mod, s = lasso_mod$lambda[i], newx = x_test)
make_metrics_tibble(
obs = test_data$tilskuere,
pred = pred,
model = "Lasso",
lambda = lasso_mod$lambda[i],
periode = periode
)
}))
metrics[which.min(metrics$MSE), ]
}
# Vi laver et loop over alle perioder i features_listen, og kører
# run_ridge_best_lambda. Og vi bruger bind_rows funktioenn til at binde resultaterne
# i en tibble med den bedste lambda og de bedste metrics for hver periode.
metrics_ridge_best <- bind_rows(
lapply(names(features_list), function(p) {
run_ridge_best_lambda(features_list[[p]], p)
})
)
# Vi laver et loop over alle perioder i features_listen, og kører
# run_ridge_best_lambda. Og vi bruger bind_rows funktioenn til at binde resultaterne
# i en tibble med den bedste lambda og de bedste metrics for hver periode.
metrics_ridge_best <- bind_rows(
lapply(names(features_list), function(p) {
run_ridge_best_lambda(features_list[[p]], p)
})
)
pacman::p_load("tidyverse", "rvest", "stringr", "janitor", "lubridate", "RSQLite")
Sys.getenv()
#| label: Setup
#| echo: false
#| eval: true
# Options
options(OutDec = ",")
# Pakker
pacman::p_load("knitr", "tinytex", "tidyverse")
Sys.getenv("MY_API_KEY")
api_nøgle
kamp_datoer[kamp]
vff_hjemmekampe <- read_rds("VFFdata/superstatsvff.rds")
vff_hjemmekampe <- read_rds("VFFdata/superstatsvff.rds")
Hvis der findes en .Renviron-fil, så læses den ind her.
En .Renviron-fil bruges til, at R automatisk kan læse værdier feks. API-nøgler, selvom de ikke er synlige i selve koden.
Sys.getenv() bruges i R til at hente oplysninger gemt i f.eks. .Renviron.
Kampdatoerne for VFF's hjemmekampe gemmes i kamp_datoer.
Opretter en tom liste og gemmer i dmi_list.
kamp_datoer <- vff_hjemmekampe$tidsstempel
kamp_datoer <- vff_hjemmekampe$tidsstempel
Opretter en tom liste og gemmer i dmi_list.
Looper gennem alle kampdatoer en ad gangen og henter DMI data.
Formaterer kampens tidsstempel til det format DMI-API'en kræver.
lapply() kører en funktion på hvert element listen og returnerer en ny liste.
bind_rows() samler alle liste-elementer i en samlet data frame.
dmi_df <- bind_rows(dmi_properties, .id = kamp) |>
mutate(kamp = as.integer(kamp), kamp_dato = kamp_datoer[kamp])
dmi_properties <- lapply(dmi_list, function(x) x$features$properties)
dmi_list <- list()
#| message: false
for (i in seq_along(kamp_datoer)) {
dato_format <- format(kamp_datoer[i], "%Y-%m-%dT%H:%M:%SZ")
#> URL-koder datoen så den kan bruges i API-kaldet.
#> URLencode() oversætter tegn som specialtegn.
#> F.eks. bliver 2023-07-12 19:00 til "2023-07-12%2019%3A00".så datoerne de kan bruges i URL'en.
dato_encode <- URLencode(dato_format)
#> Bygger URL'en der henter temperatur og vind for kampen index i. Alle kampe.
#> paste0() sætter tekst sammen uden mellemrum
url_temp_vind <- paste0(
"https://dmigw.govcloud.dk/v2/metObs/collections/observation/items?",
"stationId=06060",
"&datetime=", dato_encode,
"&api-key=", api_nøgle)
#> Henter DMI’s data for kampene.
#> httr::GET() sender en HTTP-forespørgsel af typen GET.
#> Det betyder, at serveren bliver bedt om at sende data fra det angivne URL.
api_kald <- httr::GET(url_temp_vind)
#> httr::content() trækker indholdet ud som tekst.
#> Læser API-svaret som ren JSON-tekst
tekst <- httr::content(api_kald, "text", encoding = "UTF-8")
#> jsonlite::fromJSON() omdanner JSON-tekst til en R-liste
#> Konverterer data så de kan gemmes i dmi_list.
dmi_list[[i]] <- jsonlite::fromJSON(tekst)
#> message() skriver til konsollen.
#> Viser løbende hvilket tidspunkt der hentes data for.
message("Henter data for:", dato_format, "\n")
}
dmi_properties <- lapply(dmi_list, function(x) x$features$properties)
dmi_properties <- lapply(dmi_list, function(x) x$features$properties)
dmi_properties <- lapply(dmi_list, function(x) x$features$properties)
dmi_df <- bind_rows(dmi_properties, .id = kamp) |>
mutate(kamp = as.integer(kamp), kamp_dato = kamp_datoer[kamp])
dmi_df <- bind_rows(dmi_properties, .id = kamp) |>
mutate(kamp = as.integer(kamp), kamp_dato = kamp_datoer[kamp])
dmi_df <- bind_rows(dmi_properties, .id = kamp) |>
mutate(kamp = as.integer(kamp), kamp_dato = kamp_datoer[kamp])
dmi_df <- bind_rows(dmi_properties, .id = kamp) |>
mutate(kamp = as.integer(kamp), kamp_dato = kamp_datoer[kamp])
